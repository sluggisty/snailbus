package main

import (
	"database/sql"
	"fmt"
	"log"
	"net/http"
	"os"

	"github.com/gin-gonic/gin"
	_ "github.com/lib/pq"
	"github.com/golang-migrate/migrate/v4"
	"github.com/golang-migrate/migrate/v4/database/postgres"
	_ "github.com/golang-migrate/migrate/v4/source/file"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
	"snailbus/internal/handlers"
	"snailbus/internal/middleware"
	"snailbus/internal/storage"

	_ "snailbus/docs" // swagger docs generated by swag
)

// @title           Snailbus API
// @version         1.0.0
// @description     Snailbus is a data ingestion and management API for receiving and storing system information collected by snail-core agents.
// @description     The API provides endpoints for ingesting collection reports from snail-core agents, querying and managing host data, and health monitoring.
// @description     All timestamps are in RFC3339 format (ISO 8601).

// @contact.name   Snailbus API Support
// @contact.url    https://github.com/sluggisty/snailbus

// @license.name  MIT
// @license.url   https://opensource.org/licenses/MIT

// @host      localhost:8080
// @BasePath  /

// @schemes   http https

func main() {
	// Initialize database connection
	databaseURL := getEnv("DATABASE_URL", "postgres://snail:snail_secret@localhost:5432/snailbus?sslmode=disable")

	// Run migrations first
	if err := runMigrations(databaseURL); err != nil {
		log.Fatalf("Failed to run migrations: %v", err)
	}

	// Initialize storage
	store, err := storage.NewPostgresStorage(databaseURL)
	if err != nil {
		log.Fatalf("Failed to initialize storage: %v", err)
	}
	defer store.Close()

	// Create handlers
	h := handlers.New(store)

	// Create Gin router
	r := gin.Default()

	// Health check endpoint
	r.GET("/health", h.Health)

	// Root endpoint
	r.GET("/", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{
			"message": "Welcome to Snailbus API",
			"version": "1.0.0",
		})
	})

	// API v1 routes
	v1 := r.Group("/api/v1")
	{
		// Public auth endpoints (no authentication required)
		auth := v1.Group("/auth")
		{
			auth.POST("/register", h.Register)
			auth.POST("/login", h.Login)
		}

		// Protected routes (require API key authentication)
		protected := v1.Group("")
		protected.Use(middleware.AuthMiddleware(store))
		{
			// Auth endpoints
			protected.GET("/auth/me", h.GetMe)

			// API key management
			protected.POST("/api-keys", h.CreateAPIKey)
			protected.GET("/api-keys", h.ListAPIKeys)
			protected.DELETE("/api-keys/:id", h.DeleteAPIKey)

			// Host management endpoints
			protected.GET("/hosts", h.ListHosts)
			protected.GET("/hosts/:host_id", h.GetHost)
			protected.DELETE("/hosts/:host_id", h.DeleteHost)
		}

		// Ingest endpoint - requires API key but allows both authenticated and unauthenticated
		// For backward compatibility, we'll make it optional initially, then require auth
		ingest := v1.Group("")
		ingest.Use(middleware.AuthMiddleware(store))
		{
			ingest.POST("/ingest", h.Ingest)
		}
	}

	// OpenAPI specification endpoints (generated by swag)
	r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
	
	// Legacy endpoints for backward compatibility (now serve generated spec)
	r.GET("/openapi.yaml", h.GetOpenAPISpecYAML)
	r.GET("/openapi.json", h.GetOpenAPISpecJSON)

	// Start server on port 8080
	port := getEnv("PORT", "8080")
	log.Printf("Starting Snailbus server on port %s", port)
	if err := r.Run(":" + port); err != nil {
		log.Fatalf("Failed to start server: %v", err)
	}
}

// runMigrations runs database migrations
func runMigrations(databaseURL string) error {
	// Parse database URL to get driver instance
	db, err := sql.Open("postgres", databaseURL)
	if err != nil {
		return fmt.Errorf("failed to open database for migrations: %w", err)
	}
	defer db.Close()

	driver, err := postgres.WithInstance(db, &postgres.Config{})
	if err != nil {
		return fmt.Errorf("failed to create migration driver: %w", err)
	}

	// Get migrations directory from environment or use default
	migrationsPath := getEnv("MIGRATIONS_PATH", "file://migrations")

	m, err := migrate.NewWithDatabaseInstance(
		migrationsPath,
		"postgres",
		driver,
	)
	if err != nil {
		return fmt.Errorf("failed to create migrate instance: %w", err)
	}

	// Run migrations
	if err := m.Up(); err != nil && err != migrate.ErrNoChange {
		return fmt.Errorf("failed to run migrations: %w", err)
	}

	if err == migrate.ErrNoChange {
		log.Println("Database is up to date, no migrations to run")
	} else {
		log.Println("Database migrations completed successfully")
	}

	return nil
}

// getEnv gets an environment variable or returns a default value
func getEnv(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}
