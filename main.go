package main

import (
	"context"
	"database/sql"
	"flag"
	"fmt"
	"net/http"
	"os"
	"os/signal"
	"sync"
	"syscall"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/golang-migrate/migrate/v4"
	"github.com/golang-migrate/migrate/v4/database/postgres"
	_ "github.com/golang-migrate/migrate/v4/source/file"
	_ "github.com/lib/pq"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"

	"snailbus/internal/config"
	"snailbus/internal/handlers"
	"snailbus/internal/logger"
	"snailbus/internal/metrics"
	"snailbus/internal/middleware"
	"snailbus/internal/storage"

	_ "snailbus/docs" // swagger docs generated by swag
)

var (
	registerMetricsOnce sync.Once
)

// Version information set at build time via ldflags
var (
	Version   = "dev"
	Commit    = "unknown"
	BuildTime = "unknown"
)

// @title           Snailbus API
// @version         1.0.0
// @description     Snailbus is a data ingestion and management API for receiving and storing system information collected by snail-core agents.
// @description     The API provides endpoints for ingesting collection reports from snail-core agents, querying and managing host data, and health monitoring.
// @description     All timestamps are in RFC3339 format (ISO 8601).

// @contact.name   Snailbus API Support
// @contact.url    https://github.com/sluggisty/snailbus

// @license.name  MIT
// @license.url   https://opensource.org/licenses/MIT

// @host      localhost:8080
// @BasePath  /

// @schemes   http https

func main() {
	// Parse command line arguments
	var validateConfigCmd = flag.Bool("validate-config", false, "Validate configuration and exit")
	flag.Parse()

	// Load and validate configuration
	cfg, err := config.Load()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Configuration error: %v\n", err)
		os.Exit(1)
	}

	// If validate-config flag is set, validate and exit
	if *validateConfigCmd {
		fmt.Println("✅ Configuration validation successful!")
		fmt.Printf("Database URL: %s\n", cfg.DatabaseURL)
		fmt.Printf("Server Port: %s\n", cfg.Port)
		fmt.Printf("Metrics Port: %s\n", cfg.MetricsPort)
		fmt.Printf("Log Level: %s\n", cfg.LogLevel)
		fmt.Printf("Gin Mode: %s\n", cfg.GinMode)
		os.Exit(0)
	}

	// Initialize structured logging
	logger.Init()

	databaseURL := cfg.DatabaseURL

	// Run migrations first
	if err := runMigrations(databaseURL, cfg.MigrationsPath); err != nil {
		logger.Logger.Fatal().Err(err).Msg("Failed to run migrations")
	}

	// Initialize storage
	store, err := storage.NewPostgresStorage(databaseURL)
	if err != nil {
		logger.Logger.Fatal().Err(err).Msg("Failed to initialize storage")
	}
	defer store.Close()

	// Register database metrics
	metrics.RegisterDBMetrics(store.DB(), "snailbus")

	// Register Go runtime metrics (only once, ignore if already registered)
	registerMetricsOnce.Do(func() {
		// Try to register Go collector
		if err := prometheus.Register(prometheus.NewGoCollector()); err != nil {
			// Check if it's an AlreadyRegisteredError - this is expected and harmless
			if _, ok := err.(prometheus.AlreadyRegisteredError); ok {
				// Already registered, this is fine - don't log as it's expected
			} else {
				// Some other error - log it
				logger.Logger.Warn().Err(err).Msg("Failed to register Go collector")
			}
		}
		// Try to register Process collector
		if err := prometheus.Register(prometheus.NewProcessCollector(prometheus.ProcessCollectorOpts{})); err != nil {
			// Check if it's an AlreadyRegisteredError - this is expected and harmless
			if _, ok := err.(prometheus.AlreadyRegisteredError); ok {
				// Already registered, this is fine - don't log as it's expected
			} else {
				// Some other error - log it
				logger.Logger.Warn().Err(err).Msg("Failed to register Process collector")
			}
		}
	})

	// Create handlers
	h := handlers.New(store)

	// Create Gin router
	r := gin.Default()

	// Add request ID middleware (should be first to capture all requests)
	r.Use(middleware.RequestIDMiddleware())

	// Add request size limit middleware (should be early to prevent large requests)
	r.Use(middleware.RequestSizeLimit(cfg))

	// Add security headers middleware (should be early to set headers for all responses)
	r.Use(middleware.SecurityHeadersMiddleware())

	// Add CSRF token middleware (sets CSRF token cookie for frontend access)
	r.Use(middleware.CSRFTokenMiddleware())

	// Add CSRF protection for state-changing requests
	r.Use(middleware.CSRFTokens())

	// Add metrics middleware (should be early to capture all requests)
	r.Use(middleware.MetricsMiddleware())

	// Initialize rate limiting middleware
	generalRateLimiter, registerRateLimiter, loginRateLimiter, ingestRateLimiter := middleware.InitRateLimitMiddleware()

	// Health check endpoint
	r.GET("/health", h.Health)

	// Root endpoint
	r.GET("/", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{
			"message":    "Welcome to Snailbus API",
			"version":    Version,
			"commit":     Commit,
			"build_time": BuildTime,
		})
	})

	// API v1 routes
	v1 := r.Group("/api/v1")
	{
		// Public auth endpoints (no authentication required)
		auth := v1.Group("/auth")
		{
			auth.POST("/register", registerRateLimiter, h.Register)
			auth.POST("/login", loginRateLimiter, h.Login)
			auth.POST("/api-key", loginRateLimiter, h.GetAPIKeyFromCredentials) // Get API key from username/password (use login limit)
		}

		// Protected routes (require API key authentication)
		protected := v1.Group("")
		protected.Use(generalRateLimiter) // Apply general API key rate limiting
		protected.Use(middleware.AuthMiddleware(store))
		protected.Use(middleware.OrgContextMiddleware()) // Extract org_id and role for easy access
		{
			// Auth endpoints - accessible to all authenticated users
			protected.GET("/auth/me", h.GetMe)

			// API key management - accessible to all authenticated users
			protected.POST("/api-keys", h.CreateAPIKey)
			protected.GET("/api-keys", h.ListAPIKeys)
			protected.DELETE("/api-keys/:id", h.DeleteAPIKey)

			// Host management endpoints - viewing accessible to all authenticated users
			protected.GET("/hosts", h.ListHosts)
			protected.GET("/hosts/:host_id", h.GetHost)

			// Host deletion - requires editor or admin role
			editorOrAdmin := protected.Group("")
			editorOrAdmin.Use(middleware.RequireRole("editor", "admin"))
			{
				editorOrAdmin.DELETE("/hosts/:host_id", h.DeleteHost)
			}

			// User management endpoints - admin only
			adminOnly := protected.Group("")
			adminOnly.Use(middleware.RequireRole("admin"))
			{
				adminOnly.GET("/users", h.ListUsers)
				adminOnly.POST("/users", h.CreateUser)
				adminOnly.PUT("/users/:user_id/role", h.UpdateUserRole)
				adminOnly.DELETE("/users/:user_id", h.DeleteUser)
			}
		}

		// Ingest endpoint - requires editor or admin role (viewers cannot upload)
		ingest := v1.Group("")
		ingest.Use(ingestRateLimiter) // Apply stricter rate limiting for ingest
		ingest.Use(middleware.AuthMiddleware(store))
		ingest.Use(middleware.OrgContextMiddleware()) // Extract org_id and role
		ingest.Use(middleware.RequireRole("editor", "admin"))
		{
			ingest.POST("/ingest", h.Ingest)
		}
	}

	// OpenAPI specification endpoints (generated by swag)
	r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	// Legacy endpoints for backward compatibility (now serve generated spec)
	r.GET("/openapi.yaml", h.GetOpenAPISpecYAML)
	r.GET("/openapi.json", h.GetOpenAPISpecJSON)

	// Start main API server
	apiServer := &http.Server{
		Addr:    ":" + cfg.Port,
		Handler: r,
	}

	// Start metrics server on separate port
	// This provides network-level security - metrics are only accessible from localhost/internal network
	metricsMux := http.NewServeMux()
	metricsMux.Handle("/metrics", promhttp.Handler())
	metricsServer := &http.Server{
		Addr:    cfg.MetricsBindAddr + ":" + cfg.MetricsPort,
		Handler: metricsMux,
	}

	// Start both servers concurrently
	var wg sync.WaitGroup
	wg.Add(2)

	// Start main API server
	go func() {
		defer wg.Done()
		logger.Logger.Info().
			Str("port", cfg.Port).
			Str("version", Version).
			Str("commit", Commit).
			Str("build_time", BuildTime).
			Msg("Starting Snailbus API server")
		if err := apiServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			logger.Logger.Fatal().Err(err).Msg("Failed to start API server")
		}
	}()

	// Start metrics server
	go func() {
		defer wg.Done()
		logger.Logger.Info().
			Str("address", cfg.MetricsBindAddr).
			Str("port", cfg.MetricsPort).
			Msg("Starting metrics server")
		if err := metricsServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			logger.Logger.Fatal().Err(err).Msg("Failed to start metrics server")
		}
	}()

	// Wait for interrupt signal to gracefully shutdown the servers
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit

	logger.Logger.Info().Msg("Received shutdown signal, initiating graceful shutdown...")

	// Create shutdown context with 30 second timeout
	shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer shutdownCancel()

	logger.Logger.Info().Msg("Step 1/4: Waiting for in-flight HTTP requests to complete (30s timeout)...")

	// Gracefully shutdown API server (waits for in-flight requests)
	if err := apiServer.Shutdown(shutdownCtx); err != nil {
		logger.Logger.Error().Err(err).Msg("Error shutting down API server")
	} else {
		logger.Logger.Info().Msg("✓ API server shut down successfully")
	}

	// Gracefully shutdown metrics server
	if err := metricsServer.Shutdown(shutdownCtx); err != nil {
		logger.Logger.Error().Err(err).Msg("Error shutting down metrics server")
	} else {
		logger.Logger.Info().Msg("✓ Metrics server shut down successfully")
	}

	logger.Logger.Info().Msg("Step 2/4: Closing database connections...")

	// Close database connections properly
	if store != nil {
		if db := store.DB(); db != nil {
			if err := db.Close(); err != nil {
				logger.Logger.Error().Err(err).Msg("Error closing database connection")
			} else {
				logger.Logger.Info().Msg("✓ Database connections closed successfully")
			}
		}
	}

	logger.Logger.Info().Msg("Step 3/4: Flushing logs...")

	// Flush any buffered logs (zerolog handles this automatically, but we log completion)
	logger.Logger.Info().Msg("✓ Log flushing completed")

	logger.Logger.Info().Msg("Step 4/4: Graceful shutdown completed")

	// Check if shutdown was graceful or forced
	if shutdownCtx.Err() == context.DeadlineExceeded {
		logger.Logger.Warn().Msg("Shutdown timeout exceeded - some connections may have been forcefully closed")
	} else {
		logger.Logger.Info().Msg("All servers stopped gracefully")
	}
}

// runMigrations runs database migrations
func runMigrations(databaseURL, migrationsPath string) error {
	// Parse database URL to get driver instance
	db, err := sql.Open("postgres", databaseURL)
	if err != nil {
		return fmt.Errorf("failed to open database for migrations: %w", err)
	}
	defer db.Close()

	driver, err := postgres.WithInstance(db, &postgres.Config{})
	if err != nil {
		return fmt.Errorf("failed to create migration driver: %w", err)
	}

	// migrationsPath is now passed as parameter

	m, err := migrate.NewWithDatabaseInstance(
		migrationsPath,
		"postgres",
		driver,
	)
	if err != nil {
		return fmt.Errorf("failed to create migrate instance: %w", err)
	}

	// Run migrations
	if err := m.Up(); err != nil && err != migrate.ErrNoChange {
		return fmt.Errorf("failed to run migrations: %w", err)
	}

	if err == migrate.ErrNoChange {
		logger.Logger.Info().Msg("Database is up to date, no migrations to run")
	} else {
		logger.Logger.Info().Msg("Database migrations completed successfully")
	}

	return nil
}

// getEnv gets an environment variable or returns a default value
func getEnv(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}
